<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interacción de objetos canvas</title>
    <style>
        #canvas-container {
            position: relative;
        }

        #canvas {
            background-color: #87CEFA; /* Fondo azul claro */
        }

        #coordenadas {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: Arial;
            font-size: 16px;
            color: black;
        }

        #puntaje {
            position: absolute;
            top: 40px;
            left: 10px;
            font-family: Arial;
            font-size: 16px;
            color: black;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div id="coordenadas">X: 0, Y: 0</div>
        <div id="puntaje">Puntaje: 0</div>
    </div>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        const window_height = window.innerHeight;
        const window_width = window.innerWidth;

        canvas.height = window_height;
        canvas.width = window_width;

        canvas.style.backgroundColor = "#87CEFA"; /* Fondo azul claro */

        class Circle {
            constructor(x, y, radius, color, text, speed) {
                this.posx = x;
                this.posy = y;
                this.radius = radius;
                this.color = color;
                this.text = text;
                this.speed = speed;
                this.dx = 0; // Los círculos no tienen velocidad horizontal
                this.dy = -this.speed; // La velocidad vertical es negativa para que se muevan hacia arriba
                this.colliding = false;
            }

            draw(context) {
                context.beginPath();
                context.fillStyle = "#ffffff"; /* Color blanco */
                context.shadowColor = "#ffffff"; /* Sombra blanca */
                context.shadowBlur = 10; /* Borrosidad de la sombra */
                context.strokeStyle = this.color;
                context.textAlign = "center";
                context.textBaseline = "middle";
                context.font = "20px Arial";
                context.fillText(this.text, this.posx, this.posy);
                context.arc(this.posx, this.posy, this.radius, 0, Math.PI * 2, false);
                context.fill();
                context.closePath();
            }

            colisionOcurriendo(CirculoI) {
                const distanceX = this.posx - CirculoI.posx;
                const distanceY = this.posy - CirculoI.posy;
                const distance = Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));
                return distance < this.radius + CirculoI.radius;
            }

            update(circles) {
                let collided = false;

                // Comprobar colisión con otros círculos
                for (let i = 0; i < circles.length; i++) {
                    if (circles[i] !== this) {
                        if (this.colisionOcurriendo(circles[i])) {
                            collided = true;
                            // Calcular el ángulo para el rebote
                            const angle = Math.atan2(this.posy - circles[i].posy, this.posx - circles[i].posx);
                            // Calcular un ángulo aleatorio para el rebote
                            const randomAngle = angle + (Math.random() - 0.5) * Math.PI / 2;
                            this.dx = Math.cos(randomAngle) * this.speed;
                            this.dy = Math.sin(randomAngle) * this.speed;
                            this.colliding = true;
                            break;
                        }
                    }
                }

                if (!collided) {
                    this.colliding = false;
                }

                // Actualizar posición del círculo
                this.posx += this.dx;
                this.posy += this.dy;

                // Si el círculo sale del borde superior, eliminarlo
                if (this.posy + this.radius < 0) {
                    const index = circles.indexOf(this);
                    if (index !== -1) {
                        circles.splice(index, 1);
                    }
                }
            }
        }

        let arrayCircle = [];
        let puntaje = 0; // Mover puntaje aquí para que sea global

        function addCircle() {
            const randomX = Math.random() * window_width;
            const randomRadius = Math.floor(Math.random() * 100 + 30);
            const randomSpeed = Math.random() * 3 + 1; // Velocidad aleatoria entre 1 y 4

            const myCircle = new Circle(randomX, window_height + randomRadius, randomRadius, "blue", arrayCircle.length + 1, randomSpeed);
            arrayCircle.push(myCircle);
        }

        const circleInterval = setInterval(addCircle, 1500); // Agrega un círculo cada 1.5 segundos

        function updateCircles(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, window_width, window_height);

            // Iterar sobre los círculos y actualizarlos
            for (let i = 0; i < arrayCircle.length; i++) {
                arrayCircle[i].update(arrayCircle);
                arrayCircle[i].draw(ctx);
            }

            // Solicitar el siguiente frame de animación
            requestAnimationFrame(updateCircles);
        }

        let lastTime = 0;
        updateCircles(); // Iniciar la animación

        canvas.addEventListener('click', function (event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Iterar sobre los círculos para comprobar si se hizo clic en alguno
            for (let i = 0; i < arrayCircle.length; i++) {
                const circle = arrayCircle[i];
                const distance = Math.sqrt((mouseX - circle.posx) ** 2 + (mouseY - circle.posy) ** 2);

                // Si la distancia entre el punto del clic y el centro del círculo es menor que el radio, entonces se hizo clic dentro del círculo
                if (distance <= circle.radius) {
                    // Eliminar el círculo del array
                    arrayCircle.splice(i, 1);
                    // Incrementar y mostrar el puntaje
                    puntaje++;
                    document.getElementById("puntaje").innerText = `Puntaje: ${puntaje}`;
                    break;
                }
            }
        });

        let mouseX = 0;
        let mouseY = 0;

        canvas.addEventListener('mousemove', function (event) {
            const rect = canvas.getBoundingClientRect();
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCoordinates();
            drawPuntaje();
            document.getElementById("coordenadas").innerText = `X: ${mouseX}, Y: ${mouseY}`;
        });

        function drawCoordinates() {
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.fillText('X: ' + mouseX, 20, 20);
            ctx.fillText('Y: ' + mouseY, 20, 40);
        }

        function drawPuntaje() {
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.fillText(`Puntaje: ${puntaje}`, 20, 70);
        }
    </script>
</body>

</html>
